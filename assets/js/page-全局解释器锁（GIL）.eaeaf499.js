(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{729:function(t,v,_){"use strict";_.r(v);var h=_(1),n=Object(h.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"全局解释器锁-gil"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局解释器锁-gil"}},[t._v("#")]),t._v(" 全局解释器锁（GIL）")]),t._v(" "),_("p",[t._v("Python 中要使用多线程和线程锁，那一定会涉及到 GIL 的知识点，这样是 Python 这门语言在多线程处理的特殊之处。")]),t._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),_("p",[t._v("在大多数环境中，单核 CPU 情况下，本质上某一时刻只能有一个线程被执行。多核 CPU 则可以支持多个线程同时执行。")]),t._v(" "),_("p",[t._v("但是在 Python 中，无论 CPU 有多少核，同时只能执行一个线程。这是由于 GIL 的存在导致的。")]),t._v(" "),_("p",[t._v("GIL 的全称是 Global Interpreter Lock（全局解释器锁），是 Python 设计之初为了数据安全所做的决定。Python 中的某个线程想要执行，必须先拿到 GIL。可以把 GIL 看作是执行任务的「通行证」，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。GIL 只在 CPython 解释器中才有，因为 CPython 调用的是 C 语言的原生线程，不能直接操作 CPU，只能利用 GIL 保证同一时间只能有一个线程拿到数据。在 PyPy 和 JPython 中没有 GIL。")]),t._v(" "),_("h2",{attrs:{id:"python-多线程的工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#python-多线程的工作流程"}},[t._v("#")]),t._v(" Python 多线程的工作流程")]),t._v(" "),_("ul",[_("li",[t._v("拿到公共数据")]),t._v(" "),_("li",[t._v("申请 GIL")]),t._v(" "),_("li",[t._v("Python 解释器调用操作系统原生线程")]),t._v(" "),_("li",[t._v("CPU 执行运算")]),t._v(" "),_("li",[t._v("当该线程执行一段时间消耗完，无论任务是否已经执行完毕，都会释放 GIL")]),t._v(" "),_("li",[t._v("下一个被 CPU 调度的线程重复上面的过程")])]),t._v(" "),_("h2",{attrs:{id:"python-多线程还有用吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#python-多线程还有用吗"}},[t._v("#")]),t._v(" Python 多线程还有用吗")]),t._v(" "),_("p",[t._v("Python 针对不同类型的任务，多线程执行效率是不同的。")]),t._v(" "),_("ul",[_("li",[t._v("对于 CPU 密集型任务（各种循环处理、计算等等），由于计算工作多，ticks 计数很快就会达到阈值，然后触发 GIL 的释放与再竞争（多个线程来回切换是需要消耗资源的）。"),_("strong",[t._v("所以 Python 下的多线程对 CPU 密集型任务并不友好")]),t._v("。")]),t._v(" "),_("li",[t._v("对于 IO 密集型任务（文件处理、网络通信等涉及数据读写的操作），多线程能够有效提升效率（单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU 的资源，从而能提升程序执行效率）。"),_("strong",[t._v("所以 Python 的多线程对 IO 密集型任务比较友好")]),t._v("。")])]),t._v(" "),_("blockquote",[_("ul",[_("li",[t._v("ticks 可以看作是 Python 自身的一个计数器，专门作用于 GIL，每次释放后归零，这个计数可以通过 "),_("code",[t._v("sys.setcheckinterval")]),t._v(" 来调整。")]),t._v(" "),_("li",[t._v("Python2.x 里，GIL 的释放逻辑是当前线程遇见 IO 操作或者 ticks 计数达到 100；python3.x 中，GIL 不使用 ticks 计数，改为使用计时器即执行时间达到设定阈值后，释放当前线程的 GIL。")])])]),t._v(" "),_("p",[t._v("并且由于 GIL 锁存在，Python 里一个进程永远只能同时执行一个线程（拿到 GIL 的线程才能执行），所以在多核 CPU 上，Python 的多线程效率并不高，倒不如使用多进程了。")]),t._v(" "),_("h2",{attrs:{id:"为什么不能去掉-gil"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能去掉-gil"}},[t._v("#")]),t._v(" 为什么不能去掉 GIL")]),t._v(" "),_("p",[t._v("首先，在早期的 Python 解释器依赖较多的全局状态，传承下来，使得想要移除当今的 GIL 变得更加困难。")]),t._v(" "),_("p",[t._v("其次，对于程序员而言，仅仅是理解 GIL 的实现就需要对操作系统设计、多线程编程、C语言、解释器设计和 CPython 解释器的实现有着非常彻底的理解，更不用说对它进行修改删除了。")]),t._v(" "),_("p",[t._v("总之，整体技术难度大，会对当前内部框架产生根本性的影响，牵一发而动全身。")]),t._v(" "),_("p",[t._v("虽然，在 Python 的不同解释器实现中，如 PyPy 就移除了 GIL，其执行速度更快（不单单是去除 GIL 的原因）。但是，我们通常使用的 CPython 解释器版本占有着统治地位的使用量。")]),t._v(" "),_("h2",{attrs:{id:"实际使用中的建议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实际使用中的建议"}},[t._v("#")]),t._v(" 实际使用中的建议")]),t._v(" "),_("p",[_("strong",[t._v("Python 中想要充分利用多核 CPU，就用多进程。因为每个进程有各自独立的 GIL，互不干扰，这样就可以真正意义上的并行执行")]),t._v("。在 Python 中，多进程的执行效率优于多线程（仅仅针对多核 CPU 而言）。同时建议在 IO 密集型任务中使用多线程，在计算密集型任务中使用多进程。")]),t._v(" "),_("p",[t._v("另外，也可以深入研究 Python 的协程机制。")]),t._v(" "),_("p",[t._v("（完）")])])}),[],!1,null,null,null);v.default=n.exports}}]);